--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -1262,7 +_,7 @@
 
     @Override
     public World createWorld(WorldCreator creator) {
-        if (true) throw new UnsupportedOperationException(); // Folia - not implemented properly yet
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Can only create worlds on global tick"); // Canvas - region threading
         Preconditions.checkState(this.console.getAllLevels().iterator().hasNext(), "Cannot create additional worlds on STARTUP");
         //Preconditions.checkState(!this.console.isIteratingOverLevels, "Cannot create a world while worlds are being ticked"); // Paper - Cat - Temp disable. We'll see how this goes.
         Preconditions.checkArgument(creator != null, "WorldCreator cannot be null");
@@ -1441,7 +_,21 @@
         }
 
         this.console.addLevel(serverLevel); // Paper - Put world into worldlist before initing the world; move up
-        this.console.initWorld(serverLevel, primaryLevelData, primaryLevelData, primaryLevelData.worldGenOptions());
+        // Canvas start - rewrite world load and unload
+        // creating worlds isn't too hard, we just need to delay world init
+        io.papermc.paper.threadedregions.RegionizedServer.getInstance().addWorld(serverLevel);
+        int loadRegionRadius = 1024 >> 4;
+        serverLevel.randomSpawnSelection = new net.minecraft.world.level.ChunkPos(serverLevel.getChunkSource().randomState().sampler().findSpawnPosition());
+        for (int currX = -loadRegionRadius; currX <= loadRegionRadius; ++currX) {
+            for (int currZ = -loadRegionRadius; currZ <= loadRegionRadius; ++currZ) {
+                net.minecraft.world.level.ChunkPos pos = new net.minecraft.world.level.ChunkPos(currX + serverLevel.randomSpawnSelection.x, currZ + serverLevel.randomSpawnSelection.z);
+                serverLevel.moonrise$getChunkTaskScheduler().chunkHolderManager.addTicketAtLevel(
+                    net.minecraft.server.level.TicketType.UNKNOWN, pos, ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkHolderManager.MAX_TICKET_LEVEL, null
+                );
+            }
+        }
+        // this.console.initWorld(serverLevel, primaryLevelData, primaryLevelData, primaryLevelData.worldGenOptions());
+        // Canvas end - rewrite world load and unload
 
         serverLevel.setSpawnSettings(true);
         // Paper - Put world into worldlist before initing the world; move up
@@ -1453,53 +_,46 @@
         return serverLevel.getWorld();
     }
 
-    @Override
-    public boolean unloadWorld(String name, boolean save) {
+    // Canvas start - rewrite world load and unload
+    @Override
+    public void unloadWorldAsync(@NotNull String name, boolean save, final @NotNull Consumer<Boolean> callback) {
+        unloadWorldAsync(this.worlds.get(name), save, callback);
+    }
+
+    @Override
+    public void unloadWorldAsync(@NotNull World world, boolean save, final @NotNull Consumer<Boolean> callback) {
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Can only unload worlds on global tick"); // Canvas - region threading
+        ServerLevel handle = ((CraftWorld) world).getHandle();
+        if (
+            handle.canvas$worldUnloadTicket.isPresent()
+            || this.console.getLevel(handle.dimension()) == null
+            || handle.dimension() == net.minecraft.world.level.Level.OVERWORLD
+            || !handle.players().isEmpty()
+            || !(new WorldUnloadEvent(handle.getWorld()).callEvent())
+            || this.console.hasStartedShutdownThread.get()
+        ) {
+            callback.accept(false);
+            return;
+        }
+
+        try {
+            net.minecraft.server.MinecraftServer.LOGGER.info("Marking world '{}' for unload", world.getName());
+            handle.canvas$worldUnloadTicket.propagate(new io.canvasmc.canvas.util.ticket.UnloadTicket(callback, save));
+        } catch (Throwable thrown) {
+            MinecraftServer.LOGGER.error("Failed to prepare unload for world", thrown);
+        }
+    }
+    // Canvas end - rewrite world load and unload
+
+    @Override
+    public boolean unloadWorld(@NotNull String name, boolean save) {
         return this.unloadWorld(this.getWorld(name), save);
     }
 
     @Override
-    public boolean unloadWorld(World world, boolean save) {
+    public boolean unloadWorld(@NotNull World world, boolean save) {
         if (true) throw new UnsupportedOperationException(); // Folia - not implemented properly yet
-        //Preconditions.checkState(!this.console.isIteratingOverLevels, "Cannot unload a world while worlds are being ticked"); // Paper - Cat - Temp disable. We'll see how this goes.
-        if (world == null) {
-            return false;
-        }
-
-        ServerLevel handle = ((CraftWorld) world).getHandle();
-
-        if (this.console.getLevel(handle.dimension()) == null) {
-            return false;
-        }
-
-        if (handle.dimension() == net.minecraft.world.level.Level.OVERWORLD) {
-            return false;
-        }
-
-        if (!handle.players().isEmpty()) {
-            return false;
-        }
-
-        WorldUnloadEvent event = new WorldUnloadEvent(handle.getWorld());
-        if (!event.callEvent()) {
-            return false;
-        }
-
-        try {
-            if (save) {
-                handle.save(null, true, false); // Paper - Fix saving in unloadWorld
-            }
-
-            handle.getChunkSource().close(save);
-            io.papermc.paper.FeatureHooks.closeEntityManager(handle, save); // SPIGOT-6722: close entityManager // Paper - chunk system
-            handle.levelStorageAccess.close();
-        } catch (Exception ex) {
-            this.getLogger().log(Level.SEVERE, null, ex);
-        }
-
-        this.worlds.remove(world.getName().toLowerCase(Locale.ROOT));
-        this.console.removeLevel(handle);
-        return true;
+        return false; // Canvas - rewrite world load and unload
     }
 
     public DedicatedServer getServer() {
@@ -3318,4 +_,11 @@
         }
     }
     // Folia end - region TPS API
+    // Canvas start - region threading
+    // note: in impl the world is provided, same as 'getWorld()'
+    @Override
+    public <T> io.canvasmc.canvas.region.RegionTickData.IRegionizedData<T> createRegionizedData(java.util.function.BiFunction<io.canvasmc.canvas.region.RegionTickData, org.bukkit.World, T> supplier, io.canvasmc.canvas.region.RegionTickData.IRegionizedData.IRegionizedCallback<T> callback) {
+        return io.papermc.paper.threadedregions.TickRegions.TickRegionData.createRegionizedDataApiHandle(supplier, callback);
+    }
+    // Canvas end - region threading
 }
