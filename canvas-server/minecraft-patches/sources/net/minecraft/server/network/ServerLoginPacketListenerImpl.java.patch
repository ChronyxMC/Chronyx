--- a/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
@@ -53,7 +_,7 @@
 public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener, TickablePacketListener {
     private static final AtomicInteger UNIQUE_THREAD_ID = new AtomicInteger(0);
     static final Logger LOGGER = LogUtils.getLogger();
-    private static final java.util.concurrent.ExecutorService authenticatorPool = java.util.concurrent.Executors.newCachedThreadPool(new com.google.common.util.concurrent.ThreadFactoryBuilder().setNameFormat("User Authenticator #%d").setUncaughtExceptionHandler(new DefaultUncaughtExceptionHandler(LOGGER)).build()); // Paper - Cache authenticator threads
+    private static final java.util.concurrent.ExecutorService authenticatorPool = io.canvasmc.canvas.Config.INSTANCE.virtualThreads.authenticatorPool ? io.canvasmc.canvas.util.virtual.VirtualThreadUtils.createPerThreadVirtualExecutor(io.canvasmc.canvas.util.virtual.VirtualThreadUtils.buildFactory((virtual -> virtual.uncaughtExceptionHandler(new DefaultUncaughtExceptionHandler(LOGGER))))) : java.util.concurrent.Executors.newCachedThreadPool(new com.google.common.util.concurrent.ThreadFactoryBuilder().setNameFormat("User Authenticator #%d").setUncaughtExceptionHandler(new DefaultUncaughtExceptionHandler(LOGGER)).build()); // Paper - Cache authenticator threads // Canvas - virtual threads
     private static final int MAX_TICKS_BEFORE_LOGIN = 600;
     private final byte[] challenge;
     final MinecraftServer server;
@@ -101,7 +_,7 @@
             if (this.server.getPlayerList().pushPendingJoin(name, uniqueId, this.connection)) {
             // Folia end - region threading - rewrite login process
             this.verifyLoginAndFinishConnectionSetup(Objects.requireNonNull(this.authenticatedProfile));
-            } else { --this.tick; } // Folia - region threading - rewrite login process // Folia - max concurrent logins
+            } // Folia - region threading - rewrite login process // Folia - max concurrent logins // Canvas - broken implementation, remove - TODO - reimplement?
         }
 
         if (this.state == ServerLoginPacketListenerImpl.State.WAITING_FOR_DUPE_DISCONNECT
@@ -416,14 +_,25 @@
     public void handleLoginAcknowledgement(ServerboundLoginAcknowledgedPacket packet) {
         net.minecraft.network.protocol.PacketUtils.ensureRunningOnSameThread(packet, this, this.server); // CraftBukkit
         Validate.validState(this.state == ServerLoginPacketListenerImpl.State.PROTOCOL_SWITCHING, "Unexpected login acknowledgement packet");
-        this.connection.setupOutboundProtocol(ConfigurationProtocols.CLIENTBOUND);
-        CommonListenerCookie commonListenerCookie = CommonListenerCookie.createInitial(Objects.requireNonNull(this.authenticatedProfile), this.transferred);
-        ServerConfigurationPacketListenerImpl serverConfigurationPacketListenerImpl = new ServerConfigurationPacketListenerImpl(
+        // Canvas start - async connection state switch
+        final CommonListenerCookie commonListenerCookie = CommonListenerCookie.createInitial(Objects.requireNonNull(this.authenticatedProfile), this.transferred);
+        final ServerConfigurationPacketListenerImpl serverConfigurationPacketListenerImpl = new ServerConfigurationPacketListenerImpl(
             this.server, this.connection, commonListenerCookie
         );
-        this.connection.setupInboundProtocol(ConfigurationProtocols.SERVERBOUND, serverConfigurationPacketListenerImpl);
-        serverConfigurationPacketListenerImpl.startConfiguration();
-        this.state = ServerLoginPacketListenerImpl.State.ACCEPTED;
+
+        Runnable post = () ->
+            io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTask(serverConfigurationPacketListenerImpl::startConfiguration);
+
+        if (!io.canvasmc.canvas.Config.INSTANCE.networking.asyncProtocolSwitch) {
+            this.connection.setupOutboundProtocol(ConfigurationProtocols.CLIENTBOUND);
+            this.connection.setupInboundProtocol(ConfigurationProtocols.SERVERBOUND, serverConfigurationPacketListenerImpl);
+            post.run();
+            return;
+        }
+        this.connection.canvas$setupInboundProtocolAsync(ConfigurationProtocols.SERVERBOUND, serverConfigurationPacketListenerImpl, () -> {
+            this.connection.canvas$setupOutboundProtocolAsync(ConfigurationProtocols.CLIENTBOUND, post, true);
+        }, false);
+        // Canvas end - async connection state switch
     }
 
     @Override
