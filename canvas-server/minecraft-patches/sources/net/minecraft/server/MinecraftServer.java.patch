--- a/net/minecraft/server/MinecraftServer.java
+++ b/net/minecraft/server/MinecraftServer.java
@@ -286,7 +_,7 @@
     public static final long SERVER_INIT = System.nanoTime(); // Paper - Lag compensation
 
     // Folia start - regionised ticking
-    public final io.papermc.paper.threadedregions.RegionizedServer regionizedServer = new io.papermc.paper.threadedregions.RegionizedServer();
+    // Canvas - region threading
 
     @Override
     public <V> CompletableFuture<V> submit(java.util.function.Supplier<V> task) {
@@ -336,7 +_,7 @@
         thread.setUncaughtExceptionHandler((thread1, exception) -> LOGGER.error("Uncaught exception in server thread", exception));
         thread.setPriority(Thread.NORM_PRIORITY+2); // Paper - Perf: Boost priority
         if (Runtime.getRuntime().availableProcessors() > 4) {
-            thread.setPriority(8);
+            thread.setPriority(10); // Canvas - bump priority
         }
 
         S minecraftServer = (S)threadFunction.apply(thread);
@@ -733,6 +_,7 @@
                     );
                 }
             }
+            LOGGER.info("Using world distance config of {} for world '{}'", serverLevel.serverLevelData.canvas$distanceConfig, serverLevel); // Canvas - per world distance
             // Folia end - region threading
 
             // Paper - Put world into worldlist before initing the world; move up
@@ -1242,11 +_,7 @@
                 io.papermc.paper.threadedregions.RegionizedServer.getInstance().init(); // Folia - region threading - only after loading worlds
                 final long actualDoneTimeMs = System.currentTimeMillis() - org.bukkit.craftbukkit.Main.BOOT_TIME.toEpochMilli(); // Paper - Improve startup message
                 LOGGER.info("Done ({})! For help, type \"help\"", String.format(java.util.Locale.ROOT, "%.3fs", actualDoneTimeMs / 1000.00D)); // Paper - Improve startup message
-                for (;;) {
-                    try {
-                        Thread.sleep(Long.MAX_VALUE);
-                    } catch (final InterruptedException ex) {}
-                }
+                return; // Canvas - region threading
             }
             // Folia end - region threading
             // Spigot start
@@ -1357,7 +_,7 @@
             }
 
             this.onServerCrash(crashReport);
-        } finally {
+        } { // Canvas - region threading
             try {
                 this.stopped = true;
                 this.stopServer();
@@ -1601,6 +_,7 @@
                     LOGGER.info("Initialising world '" + region.world.getWorld().getName() + "' before it can be ticked...");
                     this.initWorld(region.world, region.world.serverLevelData, worldData, region.world.serverLevelData.worldGenOptions()); // Folia - delayed until first tick of world
                     region.world.checkInitialised.set(ServerLevel.WORLD_INIT_CHECKED);
+                    new io.canvasmc.canvas.event.WorldPreLoadEvent(region.world.getWorld(), io.canvasmc.canvas.event.WorldPreLoadEvent.Stage.INIT_WORLD).callEvent(); // Canvas - world pre load event
                     LOGGER.info("Initialised world '" + region.world.getWorld().getName() + "'");
                 } // else: must be checked
             }
@@ -1627,9 +_,74 @@
                 scheduler.executeTick();
             }
         }
+        // Canvas start - rewrite world load and unload
+        ServerLevel world = region.world;
+        if (world.canvas$worldUnloadTicket.isPresent()) {
+            // finish teleports
+            final ChunkPos center = region.region.getCenterChunk();
+            LOGGER.info("Beginning unload of region around chunk {} in unloading world '{}'", center, world.getWorld().getName());
+            final List<ServerLevel.PendingTeleport> pendingTeleports = world.removeAllRegionTeleports();
+            if (!pendingTeleports.isEmpty()) {
+                LOGGER.info("Completing {} pending teleports in region around chunk {} in world '{}'", pendingTeleports.size(), center, world.getWorld().getName());
+                for (final ServerLevel.PendingTeleport pendingTeleport : pendingTeleports) {
+                    LOGGER.info("Completing teleportation to target position {}", pendingTeleport.to());
+
+                    // first, add entities to entity chunk so that they will be saved
+                    for (final net.minecraft.world.entity.Entity.EntityTreeNode node : pendingTeleport.rootVehicle().getFullTree()) {
+                        // assume that world and position are set to destination here
+                        node.root.setLevel(world); // in case the pending teleport is from a portal before it finds the exact destination
+                        world.moonrise$getEntityLookup().addEntityForShutdownTeleportComplete(node.root);
+                    }
+
+                    // then, rebuild the passenger tree so that when saving only the root vehicle will be written - and if
+                    // there are any player passengers, that the later player saving will save the tree
+                    pendingTeleport.rootVehicle().restore();
+
+                    // now we are finished
+                    LOGGER.info("Completed teleportation to target position {}", pendingTeleport.to());
+                }
+            }
+
+            // essentially we need to cover the ass of dumb plugins or race conditions
+            // where a player is teleported and then the world is unloaded, allowing a small
+            // window for a race condition where the player can be thrown into an unloading
+            // world. to resolve this issue we teleport the player back to where they came from
+            // Note: this covers the following:
+            //  - Portaling
+            //  - Teleporting (via command, plugin, etc.)
+            //  - Plugin
+            for (ServerPlayer localPlayer : world.getCurrentWorldData().getLocalPlayers()) {
+                io.canvasmc.canvas.util.ServerLocation lastTeleportPos = localPlayer.canvas$lastTeleportOrigin;
+                // this *really* shouldn't ever happen... ever
+                if (lastTeleportPos == null) {
+                    LOGGER.warn("Player does not contain a last origin teleport position, skipping unload return");
+                    continue;
+                }
+                LOGGER.info("Returning player to position {}/{} due to world unload", lastTeleportPos.world(), lastTeleportPos.pos());
+                localPlayer.teleportAsync(
+                    lastTeleportPos.world(),
+                    lastTeleportPos.pos(),
+                    lastTeleportPos.yaw(), lastTeleportPos.pitch(),
+                    null,
+                    org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.UNKNOWN,
+                    net.minecraft.world.entity.Entity.TELEPORT_FLAG_LOAD_CHUNK,
+                    null
+                );
+            }
+
+            LOGGER.info("Saving chunks in region around chunk {} in world '{}'", center, world.getWorld().getName());
+            world.moonrise$getChunkTaskScheduler().chunkHolderManager.close(world.canvas$worldUnloadTicket.getOrThrow().save(), true, false, false, false);
+
+            LOGGER.info("Descheduling region around chunk {} in world '{}'", center, world.getWorld().getName());
+            io.papermc.paper.threadedregions.TickRegions.getScheduler().descheduleRegion(region.getRegionSchedulingHandle());
+            region.canvas$markClosed();
+            return;
+        }
+        // Canvas end - rewrite world load and unload
         // Folia end - region threading
         //this.tickCount++; // Folia - region threading
         //this.tickRateManager.tick(); // Folia - region threading
+        region.world.getCurrentWorldData().tpsbar.tick(); // Canvas - tpsbar
         this.tickChildren(hasTimeLeft, region); // Folia - region threading
         if (false && nanos - this.lastServerStatus >= STATUS_EXPIRE_TIME_NANOS) { // Folia - region threading
             this.lastServerStatus = nanos;
@@ -1740,6 +_,19 @@
         //io.papermc.paper.adventure.providers.ClickCallbackProviderImpl.DIALOG_CLICK_MANAGER.handleQueue(this.tickCount); // Paper // Folia - region threading - moved to global tick
         //this.getFunctions().tick(); // Folia - region threading - TODO Purge functions
 
+        // Canvas start - async save-all command
+        region.canvas$saveAllTicket.consumeIfPresent(ticket -> {
+            try {
+                LOGGER.info("Saving chunks in region around chunk {} in world '{}'", region.region.getCenterChunk(), region.region.regioniser.world.getWorld().getName());
+                region.region.regioniser.world.moonrise$getChunkTaskScheduler().chunkHolderManager.close(true, false, false, false, false, ticket.flush());
+                this.getPlayerList().saveAll();
+            } catch (Throwable thrown) {
+                ticket.exceptionPropagator().accept(thrown);
+            } finally {
+                ticket.callback().run();
+            }
+        });
+        // Canvas end - async save-all command
         // CraftBukkit start
         // Run tasks that are waiting on processing
         if (false) while (!this.processQueue.isEmpty()) { // Folia - region threading
@@ -1851,11 +_,16 @@
      */
     @Nullable
     public ServerLevel getLevel(ResourceKey<Level> dimension) {
-        return this.levels.get(dimension);
+        // Canvas start - region threading
+        ServerLevel serverLevel = this.levels.get(dimension);
+        if (serverLevel != null && serverLevel.canvas$worldUnloadTicket.isPresent()) return null;
+        return serverLevel;
+        // Canvas end - region threading
     }
 
     // CraftBukkit start
     public void addLevel(ServerLevel level) {
+        if (io.papermc.paper.threadedregions.TickRegions.getScheduler().hasStarted()) io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Can only add worlds on the global tick"); // Canvas - region threading
         Map<ResourceKey<Level>, ServerLevel> oldLevels = this.levels;
         Map<ResourceKey<Level>, ServerLevel> newLevels = Maps.newLinkedHashMap(oldLevels);
         newLevels.put(level.dimension(), level);
@@ -1863,6 +_,7 @@
     }
 
     public void removeLevel(ServerLevel level) {
+        if (io.papermc.paper.threadedregions.TickRegions.getScheduler().hasStarted()) io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Can only remove worlds on the global tick"); // Canvas - region threading
         Map<ResourceKey<Level>, ServerLevel> oldLevels = this.levels;
         Map<ResourceKey<Level>, ServerLevel> newLevels = Maps.newLinkedHashMap(oldLevels);
         newLevels.remove(level.dimension());
@@ -2221,6 +_,13 @@
         return 256;
     }
 
+    // Canvas start - no chat reports
+    public boolean canvas$ncrEnforceSecureProfile() {
+        if (io.canvasmc.canvas.Config.INSTANCE.enableNoChatReports) return false; // NCR doesn't require secure profile
+        return this.enforceSecureProfile();
+    }
+
+    // Canvas end - no chat reports
     public boolean enforceSecureProfile() {
         return false;
     }
@@ -2733,6 +_,7 @@
     }
 
     public final java.util.concurrent.ExecutorService chatExecutor = java.util.concurrent.Executors.newCachedThreadPool(
+        io.canvasmc.canvas.Config.INSTANCE.virtualThreads.chatExecutor ? io.canvasmc.canvas.util.virtual.VirtualThreadUtils.buildFactory((virtual) -> virtual.uncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(net.minecraft.server.MinecraftServer.LOGGER))) : // Canvas - virtual threads
         new com.google.common.util.concurrent.ThreadFactoryBuilder().setDaemon(true).setNameFormat("Async Chat Thread - #%d").setUncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(net.minecraft.server.MinecraftServer.LOGGER)).build()); // Paper
     public final ChatDecorator improvedChatDecorator = new io.papermc.paper.adventure.ImprovedChatDecorator(this); // Paper - adventure
 
