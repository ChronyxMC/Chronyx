--- a/net/minecraft/server/commands/SpreadPlayersCommand.java
+++ b/net/minecraft/server/commands/SpreadPlayersCommand.java
@@ -32,6 +_,45 @@
 import net.minecraft.world.scores.Team;
 
 public class SpreadPlayersCommand {
+    // Canvas start - fix commands with region threading
+    private static final RegionThreadingExecutor EXECUTOR = new RegionThreadingExecutor();
+    static {
+        EXECUTOR.start();
+    }
+
+    /**
+     * We need this as an async executor, because this shouldn't be regionized
+     * as it covers potentially unloaded regions and regions other than the source
+     * region.
+     * <p>
+     * This also can't be in the global tick because it can contain extremely heavy
+     * operations, which the global tick is not made for. So it's better to be
+     * made on an asynchronous executor instead.
+     */
+    private static final class RegionThreadingExecutor extends Thread {
+        private final java.util.Queue<Runnable> taskQueue = new java.util.concurrent.ConcurrentLinkedQueue<>();
+
+        public void queue(Runnable task) {
+            this.taskQueue.add(task);
+            java.util.concurrent.locks.LockSupport.unpark(this);
+        }
+
+        @Override
+        public void run() {
+            Runnable task;
+            for (;;) {
+                while ((task = this.taskQueue.poll()) != null) {
+                    try {
+                        task.run();
+                    } catch (Throwable thrown) {
+                        net.minecraft.server.MinecraftServer.LOGGER.error("Couldn't execute task for the 'spreadplayers' command", thrown);
+                    }
+                }
+                java.util.concurrent.locks.LockSupport.park();
+            }
+        }
+    }
+    // Canvas end - fix commands with region threading
     private static final int MAX_ITERATION_COUNT = 10000;
     private static final Dynamic4CommandExceptionType ERROR_FAILED_TO_SPREAD_TEAMS = new Dynamic4CommandExceptionType(
         (teamCount, x, z, suggestedSpread) -> Component.translatableEscape("commands.spreadplayers.failed.teams", teamCount, x, z, suggestedSpread)
@@ -112,24 +_,178 @@
             double d1 = center.y - maxRange;
             double d2 = center.x + maxRange;
             double d3 = center.y + maxRange;
-            SpreadPlayersCommand.Position[] positions = createInitialPositions(
-                randomSource, respectTeams ? getNumberOfTeams(targets) : targets.size(), d, d1, d2, d3
-            );
-            spreadPositions(center, spreadDistance, level, randomSource, d, d1, d2, d3, maxHeight, positions, respectTeams);
-            double d4 = setPlayerPositions(targets, level, positions, maxHeight, respectTeams);
-            source.sendSuccess(
-                () -> Component.translatable(
-                    "commands.spreadplayers.success." + (respectTeams ? "teams" : "entities"),
-                    positions.length,
-                    center.x,
-                    center.y,
-                    String.format(Locale.ROOT, "%.2f", d4)
-                ),
-                true
-            );
-            return positions.length;
-        }
-    }
+            // Canvas start - fix commands with region threading
+            EXECUTOR.queue(() -> {
+                RandomSource fasterRandom = io.canvasmc.canvas.Config.ENABLE_FASTER_RANDOM ?
+                    new io.canvasmc.canvas.util.FasterRandomSource(net.minecraft.world.level.levelgen.RandomSupport.generateUniqueSeed()) :
+                    new ca.spottedleaf.moonrise.common.util.SimpleThreadUnsafeRandom(net.minecraft.world.level.levelgen.RandomSupport.generateUniqueSeed());
+                // Note: createInitialPositions *is* thread-safe, and this can
+                //      actually be quite an expensive method, so we use an optimized
+                //      random source too to try and help out
+                SpreadPlayersCommand.Position[] positions = createInitialPositions(
+                    fasterRandom, targets.size(), d, d1, d2, d3
+                );
+                try {
+                    canvas$spreadRegionThreading(center, spreadDistance, level, fasterRandom, d, d1, d2, d3, maxHeight, positions);
+                } catch (CommandSyntaxException ex) {
+                    source.sendFailure(Component.literal(ex.getMessage()));
+                } catch (Throwable t) {
+                    net.minecraft.server.MinecraftServer.LOGGER.error("An error occurred while spreading players asynchronously", t);
+                }
+                double d4 = canvas$teleportEntities(targets, level, positions, maxHeight, respectTeams);
+                source.sendSuccess(
+                    () -> Component.translatable(
+                        "commands.spreadplayers.success." + (respectTeams ? "teams" : "entities"),
+                        positions.length,
+                        center.x,
+                        center.y,
+                        String.format(Locale.ROOT, "%.2f", d4)
+                    ),
+                    true
+                );
+            });
+            return targets.size(); // original is 'positions.length'
+            // Canvas end - fix commands with region threading
+        }
+    }
+    // Canvas start - fix commands with region threading
+
+    private static void canvas$spreadRegionThreading(
+        Vec2 center,
+        double spreadDistance,
+        ServerLevel world,
+        RandomSource random,
+        double minX,
+        double minZ,
+        double maxX,
+        double maxZ,
+        int maxY,
+        SpreadPlayersCommand.Position[] piles
+    ) throws CommandSyntaxException {
+        boolean needsAnotherPass = true;
+        double closestDistance = Float.MAX_VALUE;
+
+        int iteration;
+        for (iteration = 0; iteration < 10000 && needsAnotherPass; ++iteration) {
+            needsAnotherPass = false;
+            closestDistance = Float.MAX_VALUE;
+
+            for (int pileIndex = 0; pileIndex < piles.length; ++pileIndex) {
+                SpreadPlayersCommand.Position pile = piles[pileIndex];
+                int overlapCount = 0;
+                SpreadPlayersCommand.Position pushVector = new SpreadPlayersCommand.Position();
+
+                for (int otherIndex = 0; otherIndex < piles.length; ++otherIndex) {
+                    if (pileIndex != otherIndex) {
+                        SpreadPlayersCommand.Position otherPile = piles[otherIndex];
+                        double distance = pile.dist(otherPile);
+                        closestDistance = Math.min(distance, closestDistance);
+                        if (distance < spreadDistance) {
+                            ++overlapCount;
+                            pushVector.x = pushVector.x + (otherPile.x - pile.x);
+                            pushVector.z = pushVector.z + (otherPile.z - pile.z);
+                        }
+                    }
+                }
+
+                if (overlapCount > 0) {
+                    pushVector.x = pushVector.x / overlapCount;
+                    pushVector.z = pushVector.z / overlapCount;
+                    double pushLength = pushVector.getLength();
+                    if (pushLength > 0.0) {
+                        pushVector.normalize();
+                        pile.moveAway(pushVector);
+                    } else {
+                        pile.randomize(random, minX, minZ, maxX, maxZ);
+                    }
+
+                    needsAnotherPass = true;
+                }
+
+                if (pile.clamp(minX, minZ, maxX, maxZ)) {
+                    needsAnotherPass = true;
+                }
+            }
+
+            if (!needsAnotherPass) {
+                java.util.List<java.util.concurrent.CompletableFuture<Void>> futures = new java.util.ArrayList<>(piles.length);
+                java.util.concurrent.atomic.AtomicBoolean invalidPositionFound = new java.util.concurrent.atomic.AtomicBoolean(false);
+                for (SpreadPlayersCommand.Position pileToCheck : piles) {
+                    net.minecraft.world.level.ChunkPos chunkPos = new net.minecraft.world.level.ChunkPos(
+                        BlockPos.containing(pileToCheck.x, 0.0, pileToCheck.z)
+                    );
+                    final java.util.concurrent.CompletableFuture<Void> future = new java.util.concurrent.CompletableFuture<>();
+                    io.papermc.paper.threadedregions.RegionizedServer.getInstance().taskQueue.queueChunkTask(
+                        world, chunkPos.x, chunkPos.z, () -> {
+                            if (!pileToCheck.isSafe(world, maxY)) {
+                                pileToCheck.randomize(random, minX, minZ, maxX, maxZ);
+                                invalidPositionFound.set(true);
+                            }
+                            future.complete(null);
+                        }, ca.spottedleaf.concurrentutil.util.Priority.BLOCKING
+                    );
+                    futures.add(future);
+                }
+                java.util.concurrent.CompletableFuture.allOf(futures.toArray(java.util.concurrent.CompletableFuture[]::new)).join();
+                needsAnotherPass = invalidPositionFound.get();
+            }
+        }
+
+        if (closestDistance == Float.MAX_VALUE) {
+            closestDistance = 0.0;
+        }
+
+        if (iteration >= 10000) {
+            throw ERROR_FAILED_TO_SPREAD_ENTITIES.create(
+                piles.length, center.x, center.y,
+                String.format(Locale.ROOT, "%.2f", closestDistance)
+            );
+        }
+    }
+
+    private static double canvas$teleportEntities(
+        Collection<? extends Entity> entities, ServerLevel world, SpreadPlayersCommand.Position[] piles, int maxY, boolean respectTeams
+    ) {
+        int pileIndex = 0;
+        double totalMinDistance = 0.0;
+        Map<net.minecraft.world.scores.Team, SpreadPlayersCommand.Position> teamAssignments = Maps.newHashMap();
+
+        for (Entity entity : entities) {
+            if (!entity.isAlive()) continue;
+            SpreadPlayersCommand.Position pile = piles[pileIndex++];
+
+            BlockPos.MutableBlockPos blockPos = new BlockPos.MutableBlockPos(
+                (int) Math.round(Math.floor(pile.x)), 0, (int) Math.round(Math.floor(pile.z))
+            );
+            io.papermc.paper.threadedregions.RegionizedServer.getInstance().taskQueue.queueTickTaskQueue(
+                world, blockPos.getX() >> 4, blockPos.getZ() >> 4, () -> {
+                    blockPos.setY(pile.getSpawnY(world, maxY));
+                    entity.getBukkitEntity().taskScheduler.schedule((entity1) -> {
+                        entity.teleportAsync(
+                            world, blockPos.getCenter(),
+                            entity.getYRot(), entity.getXRot(), entity.getDeltaMovement(),
+                            org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.COMMAND,
+                            Entity.TELEPORT_FLAG_TELEPORT_PASSENGERS | Entity.TELEPORT_FLAG_LOAD_CHUNK, null
+                        );
+                    }, null, 0L);
+                }
+            );
+
+            double minDistanceToOther = Double.MAX_VALUE;
+
+            for (SpreadPlayersCommand.Position otherPile : piles) {
+                if (pile != otherPile) {
+                    double distance = pile.dist(otherPile);
+                    minDistanceToOther = Math.min(distance, minDistanceToOther);
+                }
+            }
+
+            totalMinDistance += minDistanceToOther;
+        }
+
+        return entities.size() < 2 ? 0.0 : totalMinDistance / entities.size();
+    }
+    // Canvas end - fix commands with region threading
 
     /**
      * Gets the number of unique teams for the given list of entities.
