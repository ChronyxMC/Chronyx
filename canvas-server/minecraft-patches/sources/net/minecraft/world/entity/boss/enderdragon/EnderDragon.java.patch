--- a/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
+++ b/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
@@ -297,20 +_,45 @@
                 this.tickPart(this.wing1, cos1 * 4.5F, 2.0, sin1 * 4.5F);
                 this.tickPart(this.wing2, cos1 * -4.5F, 2.0, sin1 * -4.5F);
                 if (this.level() instanceof ServerLevel serverLevel2 && this.hurtTime == 0) {
-                    this.knockBack(
-                        serverLevel2,
-                        serverLevel2.getEntities(
-                            this, this.wing1.getBoundingBox().inflate(4.0, 2.0, 4.0).move(0.0, -2.0, 0.0), EntitySelector.NO_CREATIVE_OR_SPECTATOR
-                        )
-                    );
-                    this.knockBack(
-                        serverLevel2,
-                        serverLevel2.getEntities(
-                            this, this.wing2.getBoundingBox().inflate(4.0, 2.0, 4.0).move(0.0, -2.0, 0.0), EntitySelector.NO_CREATIVE_OR_SPECTATOR
-                        )
-                    );
-                    this.hurt(serverLevel2, serverLevel2.getEntities(this, this.head.getBoundingBox().inflate(1.0), EntitySelector.NO_CREATIVE_OR_SPECTATOR));
-                    this.hurt(serverLevel2, serverLevel2.getEntities(this, this.neck.getBoundingBox().inflate(1.0), EntitySelector.NO_CREATIVE_OR_SPECTATOR));
+                    // Canvas start - region threading
+                    /*
+                        There is a race condition in Folia that allows
+                        the ender dragon body parts to exceed the region
+                        bounds(I know, stupid...). This fixes that race
+                        condition by individually checking if each body
+                        part is in the same region.
+                     */
+                    AABB wing1AABB = this.wing1.getBoundingBox().inflate(4.0, 2.0, 4.0).move(0.0, -2.0, 0.0); // extracted from vanilla
+                    AABB wing2AABB = this.wing2.getBoundingBox().inflate(4.0, 2.0, 4.0).move(0.0, -2.0, 0.0); // extracted from vanilla
+                    // in Vanilla, the wings do knockback, the head and neck do damage
+                    // the reason we don't attempt to load these chunks and schedule
+                    // is because those chunks could be loaded next tick, and if they
+                    // are unloaded... why would we do shit with them?
+                    if (ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(serverLevel2, wing1AABB)) {
+                        this.knockBack(
+                            serverLevel2,
+                            serverLevel2.getEntities(
+                                this, wing1AABB, EntitySelector.NO_CREATIVE_OR_SPECTATOR
+                            )
+                        );
+                    }
+                    if (ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(serverLevel2, wing2AABB)) {
+                        this.knockBack(
+                            serverLevel2,
+                            serverLevel2.getEntities(
+                                this, wing2AABB, EntitySelector.NO_CREATIVE_OR_SPECTATOR
+                            )
+                        );
+                    }
+                    AABB headAABB = this.head.getBoundingBox().inflate(1.0);
+                    AABB neckAABB = this.neck.getBoundingBox().inflate(1.0);
+                    if (ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(serverLevel2, headAABB)) {
+                        this.hurt(serverLevel2, serverLevel2.getEntities(this, headAABB, EntitySelector.NO_CREATIVE_OR_SPECTATOR));
+                    }
+                    if (ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(serverLevel2, neckAABB)) {
+                        this.hurt(serverLevel2, serverLevel2.getEntities(this, neckAABB, EntitySelector.NO_CREATIVE_OR_SPECTATOR));
+                    }
+                    // Canvas end - region threading
                 }
 
                 float sin2 = Mth.sin(this.getYRot() * (float) (Math.PI / 180.0) - this.yRotA * 0.01F);
