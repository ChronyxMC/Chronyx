--- a/net/minecraft/world/level/Level.java
+++ b/net/minecraft/world/level/Level.java
@@ -200,7 +_,7 @@
 
     @Override
     public final <T extends Entity> List<T> getEntitiesOfClass(final Class<T> entityClass, final AABB boundingBox, final Predicate<? super T> predicate) {
-        final List<T> ret = new java.util.ArrayList<>();
+        final List<T> ret = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>(); // Canvas - use optimized collection
 
         ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this).moonrise$getEntityLookup().getEntities(entityClass, null, boundingBox, ret, predicate);
 
@@ -209,7 +_,7 @@
 
     @Override
     public final List<Entity> moonrise$getHardCollidingEntities(final Entity entity, final AABB box, final Predicate<? super Entity> predicate) {
-        final List<Entity> ret = new java.util.ArrayList<>();
+        final List<Entity> ret = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>(); // Canvas - use optimized collection
 
         ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this).moonrise$getEntityLookup().getHardCollidingEntities(entity, box, ret, predicate);
 
@@ -1522,7 +_,7 @@
             // Spigot end
             if (tickingBlockEntity.isRemoved()) {
                 toRemove.add(tickingBlockEntity); // Paper - Fix MC-117075; use removeAll
-            } else if (runsNormally && this.shouldTickBlocksAt(tickingBlockEntity.getPos())) {
+            } else if (runsNormally && tickingBlockEntity.getPos() != null) { // Canvas - block entity sleeping
                 tickingBlockEntity.tick();
                 // Paper start - rewrite chunk system
                 if ((++tickedEntities & 7) == 0) {
@@ -1911,6 +_,35 @@
     public List<Entity> getPushableEntities(Entity entity, AABB boundingBox) {
         return this.getEntities(entity, boundingBox, EntitySelector.pushableBy(entity));
     }
+    // Canvas start - only players push config
+
+    public it.unimi.dsi.fastutil.objects.ObjectArrayList<net.minecraft.server.level.ServerPlayer> canvas$getIntersectingPlayers(Entity calling, AABB boundingBox, Predicate<Entity> predicate) {
+        final ca.spottedleaf.moonrise.common.list.ReferenceList<net.minecraft.server.level.ServerPlayer> players = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this).moonrise$getNearbyPlayers().getPlayers(
+            calling.blockPosition, io.canvasmc.canvas.Config.INSTANCE.entityCollisionMode.isLargePushRange() ?
+                ca.spottedleaf.moonrise.common.misc.NearbyPlayers.NearbyMapType.SPAWN_RANGE :
+                ca.spottedleaf.moonrise.common.misc.NearbyPlayers.NearbyMapType.GENERAL_REALLY_REALLY_SMALL
+        );
+
+        if (players == null) {
+            return new it.unimi.dsi.fastutil.objects.ObjectArrayList<>();
+        }
+
+        final net.minecraft.server.level.ServerPlayer[] arr = players.getRawDataUnchecked();
+        final it.unimi.dsi.fastutil.objects.ObjectArrayList<net.minecraft.server.level.ServerPlayer> serverPlayers = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>();
+        for (int i = 0; i < arr.length; i++) {
+            net.minecraft.server.level.ServerPlayer player = arr[i];
+            if (
+                player != calling
+                && boundingBox.intersects(player.getBoundingBox())
+                && predicate.test(player)
+            ) {
+                serverPlayers.add(player);
+            }
+        }
+
+        return serverPlayers;
+    }
+    // Canvas end - only players push config
 
     /**
      * Returns the Entity with the given ID, or null if it doesn't exist in this Level.
