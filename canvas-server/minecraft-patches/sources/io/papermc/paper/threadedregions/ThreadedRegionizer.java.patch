--- a/io/papermc/paper/threadedregions/ThreadedRegionizer.java
+++ b/io/papermc/paper/threadedregions/ThreadedRegionizer.java
@@ -26,7 +_,7 @@
 import java.util.function.BooleanSupplier;
 import java.util.function.Consumer;
 
-public final class ThreadedRegionizer<R extends ThreadedRegionizer.ThreadedRegionData<R, S>, S extends ThreadedRegionizer.ThreadedRegionSectionData> {
+public final class ThreadedRegionizer<R extends ThreadedRegionizer.ThreadedRegionData<R, S>, S extends ThreadedRegionizer.ThreadedRegionSectionData> implements io.canvasmc.canvas.region.WorldRegionizer { // Canvas - region threading
 
     private static final Logger LOGGER = LogUtils.getLogger();
 
@@ -671,7 +_,87 @@
         }
     }
 
-    public static final class ThreadedRegion<R extends ThreadedRegionData<R, S>, S extends ThreadedRegionSectionData> {
+    // Canvas start - region threading
+
+    @Override
+    @org.jetbrains.annotations.NotNull
+    public org.bukkit.World getWorld() {
+        return this.world.getWorld();
+    }
+
+    @Override
+    public void computeForAllChunkRegions(Consumer<io.canvasmc.canvas.region.WorldRegionizer.ChunkRegion> forEach) {
+        this.computeForAllRegions(forEach);
+    }
+
+    @Override
+    public void computeForAllChunkRegionsUnsynchronized(Consumer<io.canvasmc.canvas.region.WorldRegionizer.ChunkRegion> forEach) {
+        this.computeForAllRegionsUnsynchronised(forEach);
+    }
+
+    @Override
+    public int getSectionShift() {
+        return this.sectionChunkShift;
+    }
+
+    @Override
+    public int getRegionSectionMergeRadius() {
+        return this.regionSectionMergeRadius;
+    }
+
+    @Override
+    public int getEmptySectionCreateRadius() {
+        return this.emptySectionCreateRadius;
+    }
+
+    @Override
+    public double getMaxDeadRegionPercent() {
+        return this.maxDeadRegionPercent;
+    }
+
+    public static final class ThreadedRegion<R extends ThreadedRegionData<R, S>, S extends ThreadedRegionSectionData> implements io.canvasmc.canvas.region.WorldRegionizer.ChunkRegion {
+
+        @Override
+        public long[] getOwnedPackedChunkPositions() {
+            final boolean lock = this.regioniser.writeLockOwner != Thread.currentThread();
+            if (lock) {
+                this.regioniser.regionLock.readLock();
+            }
+            try {
+                final LongArrayList ret = new LongArrayList();
+                for (final ThreadedRegionSection<R, S> section : this.sectionByKey.values()) {
+                    ret.addAll(section.getChunks());
+                }
+
+                return ret.elements();
+            } finally {
+                if (lock) {
+                    this.regioniser.regionLock.tryUnlockRead();
+                }
+            }
+        }
+
+        @Override
+        public io.canvasmc.canvas.region.WorldRegionizer getRegionizer() {
+            return this.regioniser;
+        }
+
+        @Override
+        public io.canvasmc.canvas.region.WorldRegionizer.ChunkRegion.State getState() {
+            return switch (this.state) {
+                case STATE_TRANSIENT -> io.canvasmc.canvas.region.WorldRegionizer.ChunkRegion.State.TRANSIENT;
+                case STATE_READY -> io.canvasmc.canvas.region.WorldRegionizer.ChunkRegion.State.READY;
+                case STATE_TICKING -> io.canvasmc.canvas.region.WorldRegionizer.ChunkRegion.State.TICKING;
+                case STATE_DEAD -> io.canvasmc.canvas.region.WorldRegionizer.ChunkRegion.State.DEAD;
+                default -> throw new IllegalStateException("Unknown state");
+            };
+        }
+
+        @Override
+        public io.canvasmc.canvas.region.RegionTickData getTickData() {
+            return (TickRegions.TickRegionData) this.data;
+        }
+    // Canvas end - region threading
 
         private static final AtomicLong REGION_ID_GENERATOR = new AtomicLong();
 
