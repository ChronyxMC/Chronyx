--- a/io/papermc/paper/threadedregions/RegionizedWorldData.java
+++ b/io/papermc/paper/threadedregions/RegionizedWorldData.java
@@ -84,6 +_,7 @@
                 into.localPlayers.add(player);
                 player.setRegionData(into); // Canvas - rewrite scheduler
                 into.nearbyPlayers.addPlayer(player);
+                into.waypointManager.addPlayer(player); // Canvas - region threading - restore waypoints
             }
             for (final Entity entity : from.allEntities) {
                 into.allEntities.add(entity);
@@ -121,7 +_,13 @@
             }
             for (final TickingBlockEntity tileEntityWrapped : from.blockEntityTickers) {
                 into.blockEntityTickers.add(tileEntityWrapped);
-                final BlockEntity tileEntity = tileEntityWrapped.getTileEntity();
+                // Canvas start - block entity sleeping
+                final BlockEntity tileEntity;
+                if (tileEntityWrapped instanceof net.minecraft.world.level.chunk.LevelChunk.RebindableTickingBlockEntityWrapper rebindable
+                    && rebindable.ticker instanceof io.canvasmc.canvas.chunk.block.SleepingBlockEntity.SleepingTicker sleepingTicker) {
+                    tileEntity = sleepingTicker.getTileEntityForRegionOperation(); // ensure we still update the entity ticks
+                } else tileEntity = tileEntityWrapped.getTileEntity();
+                // Canvas end - block entity sleeping
                 if (tileEntity != null) {
                     tileEntity.updateTicks(fromTickOffset, fromRedstoneTimeOffset);
                 }
@@ -184,6 +_,10 @@
                 into.localPlayers.add(player);
                 player.setRegionData(into); // Canvas - rewrite scheduler
                 into.nearbyPlayers.addPlayer(player);
+                // Canvas start - region threading - restore waypoints
+                from.waypointManager.removePlayer(player);
+                into.waypointManager.addPlayer(player);
+                // Canvas end - region threading - restore waypoints
             }
             for (final Entity entity : from.allEntities) {
                 final ChunkPos pos = entity.chunkPosition();
@@ -254,7 +_,18 @@
                   //       marked as removed. So if there is no section, it's probably removed!
             }
             for (final TickingBlockEntity tileEntity : from.blockEntityTickers) {
-                final BlockPos pos = tileEntity.getPos();
+                // Canvas start - block entity sleeping
+                final BlockPos pos;
+                if (tileEntity instanceof net.minecraft.world.level.chunk.LevelChunk.RebindableTickingBlockEntityWrapper rebindable
+                    && rebindable.ticker instanceof io.canvasmc.canvas.chunk.block.SleepingBlockEntity.SleepingTicker sleepingTicker) {
+                    pos = sleepingTicker.getPosForRegionOperation(); // ensure non-null, since the sleeping ticker has getPos() return null, which will crash the server on split
+                } else {
+                    pos = tileEntity.getPos();
+                }
+                if (pos == null) {
+                    throw new IllegalStateException("Pos cannot be null, class: " + tileEntity.getClass().getName());
+                }
+                // Canvas end - block entity sleeping
                 final int chunkX = pos.getX() >> 4;
                 final int chunkZ = pos.getZ() >> 4;
 
@@ -336,7 +_,7 @@
     private RegionizedServer.WorldLevelData tickData;
 
     // connections
-    public final List<Connection> connections = new ArrayList<>();
+    public final List<Connection> connections = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>(); // Canvas - optimized collection
 
     // misc. fields
     private boolean isHandlingTick;
@@ -366,8 +_,8 @@
     private final LevelTicks<Fluid> fluidLevelTicks;
 
     // tile entity ticking
-    private final List<TickingBlockEntity> pendingBlockEntityTickers = new ArrayList<>();
-    private final List<TickingBlockEntity> blockEntityTickers = new ArrayList<>();
+    private final List<TickingBlockEntity> pendingBlockEntityTickers = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>(); // Canvas - optimized collection
+    private final List<TickingBlockEntity> blockEntityTickers = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>(); // Canvas - optimized collection
     private boolean tickingBlockEntities;
 
     // time
@@ -396,6 +_,7 @@
     public boolean skipPullModeEventFire = false;
     public boolean skipPushModeEventFire = false;
     public boolean skipHopperEvents = false;
+    public boolean skipHopperSearchItemEvents = false; // Canvas - optimize hoppers
     // Paper end - Optimize Hoppers
     public long lastMidTickExecute;
     public long lastMidTickExecuteFailure;
@@ -404,8 +_,8 @@
     public final NeighborUpdater neighborUpdater;
     public boolean captureBlockStates = false;
     public boolean captureTreeGeneration = false;
-    public final Map<BlockPos, CraftBlockState> capturedBlockStates = new java.util.LinkedHashMap<>(); // Paper
-    public final Map<BlockPos, BlockEntity> capturedTileEntities = new java.util.LinkedHashMap<>(); // Paper
+    public final Map<BlockPos, CraftBlockState> capturedBlockStates = new it.unimi.dsi.fastutil.objects.Object2ObjectLinkedOpenHashMap<>(); // Paper // Canvas - optimized collection
+    public final Map<BlockPos, BlockEntity> capturedTileEntities = new it.unimi.dsi.fastutil.objects.Object2ObjectLinkedOpenHashMap<>(); // Paper // Canvas - optimized collection
     public List<ItemEntity> captureDrops;
     // Paper start
     public int wakeupInactiveRemainingAnimals;
@@ -420,11 +_,16 @@
     public boolean shouldSignal = true;
     public final Map<ServerExplosion.CacheKey, Float> explosionDensityCache = new HashMap<>(64, 0.25f);
     public final PathTypeCache pathTypesByPosCache = new PathTypeCache();
-    public final List<LevelChunk> temporaryChunkTickList = new java.util.ArrayList<>();
+    public final List<LevelChunk> temporaryChunkTickList = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>(); // Canvas - optimized collection
     public final Set<ChunkHolder> chunkHoldersToBroadcast = new ReferenceLinkedOpenHashSet<>();
 
     // not transient
     public java.util.ArrayDeque<net.minecraft.world.level.block.RedstoneTorchBlock.Toggle> redstoneUpdateInfos;
+    // Canvas start - optimize fluid spread
+    // this is transient
+    public it.unimi.dsi.fastutil.longs.LongSet slopeDistanceCacheVisited = new it.unimi.dsi.fastutil.longs.LongOpenHashSet(512);
+    public net.minecraft.world.level.material.FlowingFluid.SlopeDistanceNodeDeque slopeDistanceCacheQueue = new net.minecraft.world.level.material.FlowingFluid.SlopeDistanceNodeDeque();
+    // Canvas end - optimize fluid spread
 
     // Mob spawning
     public final ca.spottedleaf.moonrise.common.misc.PositionCountingAreaMap<ServerPlayer> spawnChunkTracker = new ca.spottedleaf.moonrise.common.misc.PositionCountingAreaMap<>();
@@ -448,6 +_,13 @@
     // Redstone
     public final alternate.current.wire.WireHandler wireHandler;
     public final io.papermc.paper.redstone.RedstoneWireTurbo turbo;
+    public final net.minecraft.world.level.levelgen.BitRandomSource simpleUnsafeLocalRandom = io.canvasmc.canvas.Config.ENABLE_FASTER_RANDOM ? new io.canvasmc.canvas.util.FasterRandomSource(net.minecraft.world.level.levelgen.RandomSupport.generateUniqueSeed()) : new ca.spottedleaf.moonrise.common.util.SimpleThreadUnsafeRandom(net.minecraft.world.level.levelgen.RandomSupport.generateUniqueSeed()); // Canvas - faster unsafe random
+    public final io.canvasmc.canvas.RegionizedTpsBar tpsbar; // Canvas - tpsbar
+    public final net.minecraft.server.waypoints.ServerWaypointManager waypointManager = new net.minecraft.server.waypoints.ServerWaypointManager(); // Canvas - region threading - restore waypoints
+    public final io.canvasmc.canvas.chunk.RandomTickSystem randomTickSystem = new io.canvasmc.canvas.chunk.RandomTickSystem(); // Leaf - optimize random tick
+    public final io.canvasmc.canvas.chunk.NatureSpawnChunkMap natureSpawnChunkMap = new io.canvasmc.canvas.chunk.NatureSpawnChunkMap(); // Canvas - optimize spawn chunk collection
+    public long canvas$loadedTick = 0; // Canvas - region threading
+    public long canvas$loadedThisTick = 0; // Canvas - region threading
 
     public final io.papermc.paper.threadedregions.TickRegions.TickRegionData regionData; // Canvas - rewrite scheduler
     public RegionizedWorldData(final ServerLevel world, final io.papermc.paper.threadedregions.TickRegions.TickRegionData regionData) { // Canvas - rewrite scheduler
@@ -459,6 +_,7 @@
         this.wireHandler = new alternate.current.wire.WireHandler(world);
         this.turbo = new io.papermc.paper.redstone.RedstoneWireTurbo((RedStoneWireBlock)Blocks.REDSTONE_WIRE);
         this.regionData = regionData; // Canvas - rewrite scheduler
+        this.tpsbar = new io.canvasmc.canvas.RegionizedTpsBar(this); // Canvas - tpsbar
 
         // tasks may be drained before the region ticks, so we must set up the tick data early just in case
         this.updateTickData();
@@ -487,6 +_,7 @@
         this.skipHopperEvents = this.world.paperConfig().hopper.disableMoveEvent || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper - Perf: Optimize Hoppers
         // always subtract from server init so that the tick starts at zero, allowing us to cast to int without much worry
         this.lagCompensationTick = (System.nanoTime() - MinecraftServer.SERVER_INIT) / TickRegionScheduler.getTimeBetweenTicks(); // Canvas - rewrite scheduler
+        this.skipHopperSearchItemEvents = org.bukkit.event.inventory.HopperInventorySearchEvent.getHandlerList().getRegisteredListeners().length == 0; // Canvas - optimize hoppers
     }
 
     public NearbyPlayers getNearbyPlayers() {
@@ -617,6 +_,7 @@
             if (entity instanceof ServerPlayer player) {
                 this.localPlayers.add(player);
                 player.setRegionData(this); // Canvas - rewrite scheduler
+                this.waypointManager.addPlayer(player); // Canvas - region threading - restore waypoints
             }
             TickRegions.RegionStats.updateCurrentRegion();
         }
@@ -634,6 +_,7 @@
             if (entity instanceof ServerPlayer player) {
                 this.localPlayers.remove(player);
                 player.setRegionData(null); // Canvas - rewrite scheduler
+                this.waypointManager.removePlayer(player); // Canvas - region threading - restore waypoints
             }
             TickRegions.RegionStats.updateCurrentRegion();
         }
