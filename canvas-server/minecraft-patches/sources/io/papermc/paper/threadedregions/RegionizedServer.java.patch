--- a/io/papermc/paper/threadedregions/RegionizedServer.java
+++ b/io/papermc/paper/threadedregions/RegionizedServer.java
@@ -79,6 +_,12 @@
         // that essentially crashes the server on the first tick of a freshly generated world.
         // This fixes it, because the race condition is caused by the global tick not being run first
         // which is required to process ticket updates so we don't fail any thread ownership checks
+        // validate respawn dimension config entry first
+        net.minecraft.resources.ResourceKey<net.minecraft.world.level.Level> respawnDimension = io.canvasmc.canvas.Config.INSTANCE.fetchRespawnDimensionKey();
+        ServerLevel level = MinecraftServer.getServer().getLevel(respawnDimension);
+        if (level == null) {
+            throw new IllegalStateException("Respawn dimension invalid, could not fetch dimension from value '" + respawnDimension + "'");
+        }
         // set to 0 as initial start so the scheduler prioritizes this tick first
         this.tickHandle.setInitialStart(0);
         // Canvas end - rewrite scheduler
@@ -399,9 +_,14 @@
             }
 
             if (isNotOwnedByGlobalRegion(conn)) {
-                // we actually require that the owning regions remove the connection for us, as it is possible
-                // that ownership is transferred back to us
-                continue;
+                // Canvas start - region threading
+                if (!(conn.getPacketListener() instanceof ServerGamePacketListenerImpl gamePacketListener
+                    && gamePacketListener.player.canvas$isDisplayingEndCredits)) {
+                    // we actually require that the owning regions remove the connection for us,
+                    // as it is possible that ownership is transferred back to us
+                    continue;
+                }
+                // Canvas end - region threading
             }
 
             if (!conn.isConnected()) {
@@ -432,6 +_,42 @@
     // A global tick only updates things like weather / worldborder, basically anything in the world that is
     // NOT tied to a specific region, but rather shared amongst all of them.
     private void globalTick(final ServerLevel world, final int tickCount) {
+        // Canvas start - rewrite world load and unload
+        if (world.canvas$worldUnloadTicket.isPresent()) {
+            // we are unloading, return.
+            AtomicBoolean isSingularRegionAlive = new AtomicBoolean(false);
+            world.regioniser.computeForAllRegions((region) -> {
+                if (!region.getData().canvas$isClosed) {
+                    // region still active, possibly still saving or hasn't gotten to that yet
+                    isSingularRegionAlive.set(true);
+                }
+            });
+            if (!isSingularRegionAlive.get()) {
+                io.canvasmc.canvas.util.ticket.UnloadTicket ticket = world.canvas$worldUnloadTicket.getOrThrow();
+                LOGGER.info("Finalizing unload of world '{}'", world.getWorld().getName());
+                final boolean save = ticket.save();
+                if (save) {
+                    org.bukkit.Bukkit.getPluginManager().callEvent(new org.bukkit.event.world.WorldSaveEvent(world.getWorld()));
+                    world.saveLevelData(true);
+                }
+                world.chunkSource.getDataStorage().close();
+                // 'save' SHOULD be false, we run this on regions, and that MUST be regionized, or we crash :)
+                world.moonrise$getChunkTaskScheduler().chunkHolderManager.close(false, true, false, true, false);
+                io.papermc.paper.FeatureHooks.closeEntityManager(world, save);
+                try {
+                    world.levelStorageAccess.close();
+                } catch (java.io.IOException e) {
+                    throw new RuntimeException("Unable to close level storage access for world unload", e);
+                }
+                this.worlds.remove(world);
+                MinecraftServer.getServer().removeLevel(world);
+                MinecraftServer.getServer().server.worlds.remove(world.getWorld().getName().toLowerCase(java.util.Locale.ROOT));
+                LOGGER.info("Completed unload of world '{}'", world.getWorld().getName());
+                ticket.callback().accept(true);
+            }
+            return;
+        }
+        // Canvas end - rewrite world load and unload
         // needs
         // worldborder tick
         // advancing the weather cycle
