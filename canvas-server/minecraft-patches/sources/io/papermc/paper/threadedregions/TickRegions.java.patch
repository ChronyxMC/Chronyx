--- a/io/papermc/paper/threadedregions/TickRegions.java
+++ b/io/papermc/paper/threadedregions/TickRegions.java
@@ -169,7 +_,59 @@
         }
     }
 
-    public static final class TickRegionData implements ThreadedRegionizer.ThreadedRegionData<TickRegionData, TickRegionSectionData> {
+    // Canvas start - region threading
+    public static final class TickRegionData implements ThreadedRegionizer.ThreadedRegionData<TickRegionData, TickRegionSectionData>, io.canvasmc.canvas.region.RegionTickData {
+
+        @Override
+        public io.canvasmc.canvas.region.WorldRegionizer.ChunkRegion getRegion() {
+            return this.region;
+        }
+
+        @Override
+        public org.bukkit.World getWorld() {
+            return this.world.getWorld();
+        }
+
+        @Override
+        public <T> T getOrCreateFromIRegionizedData(io.canvasmc.canvas.region.RegionTickData.IRegionizedData<T> regionizedData) {
+            return this.getOrCreateRegionizedData(((ApiRegionizedData<T>) regionizedData).backend());
+        }
+
+        public static <T> io.canvasmc.canvas.region.RegionTickData.IRegionizedData<T> createRegionizedDataApiHandle(java.util.function.BiFunction<io.canvasmc.canvas.region.RegionTickData, org.bukkit.World, T> supplier, io.canvasmc.canvas.region.RegionTickData.IRegionizedData.IRegionizedCallback<T> callback) {
+            RegionizedData<T> foliaRegionizedData = new RegionizedData<>(null,
+                (tickRegionData) -> supplier.apply(tickRegionData, tickRegionData.getWorld()), new RegionizedData.RegioniserCallback<T>() {
+                    @Override
+                    public void merge(final T from, final T into, final long fromTickOffset) {
+                        callback.merge(from, into, fromTickOffset);
+                    }
+
+                    @Override
+                    public void split(
+                        final T from, final int chunkToRegionShift,
+                        final Long2ReferenceOpenHashMap<T> regionToData, final ReferenceOpenHashSet<T> dataSet
+                    ) {
+                        callback.split(from, chunkToRegionShift, regionToData, dataSet);
+                    }
+                }
+            );
+            return new ApiRegionizedData<>(
+                foliaRegionizedData, callback
+            );
+        }
+
+        public record ApiRegionizedData<A>(RegionizedData<A> backend, io.canvasmc.canvas.region.RegionTickData.IRegionizedData.IRegionizedCallback<A> callback) implements io.canvasmc.canvas.region.RegionTickData.IRegionizedData<A>{
+
+            @Override
+            public A createValue(io.canvasmc.canvas.region.RegionTickData regionTickData) {
+                return backend.createNewValue((TickRegionData) regionTickData);
+            }
+
+            @Override
+            public io.canvasmc.canvas.region.RegionTickData.IRegionizedData.IRegionizedCallback<A> getCallback() {
+                return callback;
+            }
+        }
+    // Canvas end - region threading
 
         private static final AtomicLong ID_GENERATOR = new AtomicLong();
         /** Never 0L, since 0L is reserved for global region. */
@@ -194,6 +_,15 @@
         private final RegionStats regionStats;
         private final java.util.concurrent.atomic.AtomicBoolean hasPackets = new java.util.concurrent.atomic.AtomicBoolean(false); // Canvas - rewrite scheduler
 
+        // Canvas start - fix world load and unload
+        public volatile boolean canvas$isClosed = false;
+        public final io.canvasmc.canvas.util.ticket.TicketHolder<io.canvasmc.canvas.util.ticket.SaveAllTicket> canvas$saveAllTicket = new io.canvasmc.canvas.util.ticket.TicketHolder<>(); // Canvas - fix commands with region threading
+
+        public void canvas$markClosed() {
+            this.canvas$isClosed = true;
+        }
+
+        // Canvas end - fix world load and unload
         private TickRegionData(final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> region) {
             this.region = region;
             this.world = region.regioniser.world;
